<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//TaxonX//DTD Taxonomic Treatment Publishing DTD v0 20100105//EN" "tax-treatment-NS0.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tp="http://www.plazi.org/taxpub" article-type="research-article">
  <front>
    <journal-meta>
      <journal-id journal-id-type="pmc">Biodiversity Data Journal</journal-id>
      <journal-id journal-id-type="publisher-id">Biodiversity Data Journal</journal-id>
      <journal-title-group>
        <journal-title xml:lang="en">Biodiversity Data Journal</journal-title>
        <abbrev-journal-title xml:lang="en">BDJ</abbrev-journal-title>
      </journal-title-group>
      <issn pub-type="ppub">1314-2836</issn>
      <issn pub-type="epub">1314-2828</issn>
      <publisher>
        <publisher-name>Pensoft Publishers</publisher-name>
      </publisher>
    </journal-meta>
    <article-meta>
      <article-id pub-id-type="publisher-id">Biodiversity Data Journal</article-id>
      <article-id pub-id-type="doi">10.3897/BDJ.3.e5464</article-id>
      <article-id pub-id-type="other">4050</article-id>
      <article-categories>
        <subj-group subj-group-type="heading">
          <subject>Software description</subject>
        </subj-group>
        <subj-group subj-group-type="Subject classification">
          <subject>Ecological Informatics</subject>
          <subject>Data Management</subject>
          <subject>Data analysis &amp; modelling</subject>
          <subject>Bioinformatics</subject>
        </subj-group>
      </article-categories>
      <title-group>
        <article-title>A Preliminary Investigation of Reversing RML: From an RDF dataset to its Column-Based data source</article-title>
      </title-group>
      <contrib-group content-type="authors">
        <contrib contrib-type="author" corresp="yes">
          <name name-style="western">
            <surname>Allocca</surname>
            <given-names>Carlo</given-names>
          </name>
          <email xlink:type="simple">carlo@hcmr.gr</email>
          <xref ref-type="aff" rid="A1">‡</xref>
        </contrib>
        <contrib contrib-type="author" corresp="no">
          <name name-style="western">
            <surname>Gougousis</surname>
            <given-names>Alexandros</given-names>
          </name>
          <xref ref-type="aff" rid="A1">‡</xref>
        </contrib>
      </contrib-group>
      <aff id="A1">
        <label>‡</label>
        <addr-line>Hellenic Center for Marine Recearch (HCMR), Institute of Marine Biology, Biothechnology and Aquaculture (IMBBC), Thalassokosmos, 71003, Heraklion, Crete, Greece</addr-line>
      </aff>
      <author-notes>
        <fn fn-type="corresp">
          <p>Corresponding author: Carlo Allocca (<email xlink:type="simple">carlo@hcmr.gr</email>).</p>
        </fn>
        <fn fn-type="edited-by">
          <p>Academic editor: Viktor Senderov</p>
        </fn>
      </author-notes>
      <pub-date pub-type="collection">
        <year>2015</year>
      </pub-date>
      <pub-date pub-type="epub">
        <day>29</day>
        <month>07</month>
        <year>2015</year>
      </pub-date>
      <issue>3</issue>
      <elocation-id>e5464</elocation-id>
      <history>
        <date date-type="received">
          <day>18</day>
          <month>06</month>
          <year>2015</year>
        </date>
        <date date-type="accepted">
          <day>13</day>
          <month>07</month>
          <year>2015</year>
        </date>
      </history>
      <permissions>
        <copyright-statement>Carlo Allocca, Alexandros Gougousis</copyright-statement>
        <license license-type="creative-commons-attribution" xlink:href="http://creativecommons.org/licenses/by/4.0" xlink:type="simple">
          <license-p>This is an open access article distributed under the terms of the Creative Commons Attribution License 4.0 (CC-BY), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
        </license>
      </permissions>
      <abstract>
        <label>Abstract</label>
        <sec sec-type="background">
          <title>Background</title>
          <p>A large percentage of scientific data with tabular structure are published on the Web of Data as interlinked RDF datasets. When we come to the issue of long-term preservation of such RDF-based digital objects, it is important to provide full support for reusing them in the future. In particular, it should include means for both players who have no familiarity with RDF data model and, at the same time, who by working only with the native format of the data still provide sufficient information. To achieve this, we need mechanisms to bring the data back to their original format and structure.</p>
        </sec>
        <sec sec-type="new information">
          <title>New information</title>
          <p>In this paper, we investigate how to perform the reverse process for column-based data sources. In particular, we devise an algorithm, RML2CSV, and exemplify its implementation in transforming an RDF dataset into its CSV tabular structure, through the use of the same RML mapping document that was used to generate the set of RDF triples. Through a set of content-based criteria, we attempt a comparative evaluation to measure the similarity between the rebuilt CSV and the original one. The results are promising and show that, under certain assumptions, RML2CSV reconstructs the same data with the same structure, offering more advanced digital preservation services.</p>
        </sec>
      </abstract>
      <kwd-group>
        <label>Keywords</label>
        <kwd>Reverse Mapping Language</kwd>
        <kwd>RML</kwd>
        <kwd>Linked Open Data</kwd>
        <kwd>Data Preservation</kwd>
      </kwd-group>
      <funding-group>
        <award-group>
          <funding-source>The work has been supported by the LifeWatchGreece project, Funded by GSRT, ESFRI Projects, Structural Funds, OPCE II (Act Code: 384676). The authors would like to thank Nicolas Bailly and Christos Arvanitidis for fruitful discussions and for providing valuable input to the issues of this article.</funding-source>
        </award-group>
      </funding-group>
      <counts>
        <fig-count count="9"/>
        <table-count count="0"/>
        <ref-count count="26"/>
      </counts>
    </article-meta>
  </front>
  <body>
    <sec sec-type="Introduction">
      <title>Introduction</title>
      <p>To date, a large percentage of scientific data published on the Web of Data (<xref ref-type="bibr" rid="B1433011">Bizer et al. 2009</xref>) comes from tabular source (<xref ref-type="bibr" rid="B1432779">Tennison and Kellogg 2015</xref>), commonly made available in the format of comma separated values (CSV). When those contents need to be exposed to the Web following the Linked Open Data principles (<xref ref-type="bibr" rid="B1433021">Heath and Bizer 2011</xref>), they are usually transformed to interlinked RDF datasets (<xref ref-type="bibr" rid="B1433042">Tzitzikas et al. 2013</xref>). Accordingly, a major issue related to the long-term preservation (<xref ref-type="bibr" rid="B1432348">Shaon et al. 2012</xref>, <xref ref-type="bibr" rid="B1432945">Stefanova and Risch 2013a</xref>, <xref ref-type="bibr" rid="B1432282">Tzitzikas et al. 2012</xref>) of such RDF-based digital objects is the ability to provide full support for their reuse, including means for those users who have no familiarity with RDF data model, and, at the same time, work with the original tabular format of the data. The latter is a very common format to work with (<xref ref-type="bibr" rid="B1432892">Kaschner et al. 2008</xref>) for scientists including biologists, geologists and so forth, and it is often sufficient to build scientific models and test/validate their hypothesis (<xref ref-type="bibr" rid="B1432864">Candela et al. 2013</xref>). For such cases, the reuse of preserved RDF datasets would require a heavy ad-hoc pre-processing for <italic>understanding</italic> (<xref ref-type="bibr" rid="B1432364">Flouris and Meghini 2007</xref>), <italic>extracting</italic> and <italic>arranging</italic> (<xref ref-type="bibr" rid="B1432945">Stefanova and Risch 2013a</xref>) the data that satisfy the user intended use, including the transformation of the RDF data back to their original format (<xref ref-type="bibr" rid="B1432955">Stefanova and Risch 2013b</xref>). While several approaches have been proposed to map different types of data sources to RDF data model (R2RML (<xref ref-type="bibr" rid="B1433733">Das et al. 2012</xref>), RML (<xref ref-type="bibr" rid="B1433031">Dimou et al. 2013</xref>), X3ML (<xref ref-type="bibr" rid="B1432797">Kondylakis et al. 2006</xref>), just to mention a few), the opposite direction, that is transforming an RDF dataset back to its original data source has not been yet attempted to our knowledge, especially for the case of column-based sources. In this paper, we investigate the reverse process that performs the reconstruction of the original data source from an RDF dataset. We devise a generic and extendable algorithm, notably the RML2CSV, and exemplify the computing of the process for its automatic implementation. In contrast with the approaches described in the <italic>Related Works</italic> section, RML2CSV aims to rebuild a CSV data source that reflects <italic>not any</italic> but the same column-based structure and content of the original data source. To achieve this, the proposed method is based on RML (<xref ref-type="bibr" rid="B1433031">Dimou et al. 2013</xref>), in the sense that it makes use of the same RML Mapping Document - set of mapping rules - that was used to generate the RDF dataset.</p>
      <p>Based on a set of content-based criteria to measure the similarity between the original data source and the one reconstructed by RML2CSV, we evaluate the approach over a collection of real-world RDF datasets from Biodiversity domain available in the MedObis repository (<xref ref-type="bibr" rid="B1432965">Arvanitidis et al. 2006</xref>). The results demonstrate the feasibility of the reverse process under certain assumptions that are more related to the nature of the original data source and the “quality” of the mapping rules rather than related to the algorithm <italic>per se</italic>. RML2CSV rebuilds the content with the data structure as the original one, offering more advanced digital preservation services in supporting long-term access.</p>
      <p>The paper continues as in the following: The <italic>Study Area Description</italic> section briefly describes the underlying R2RML and RML mapping languages, demonstrating how they work in practice for exposing a CSV data source as an RDF dataset, and introduces the reverse process. It also details the main assumptions under which we analyse and develop the reverse process. The <italic>Design Description and Implementation</italic> sections describe the RML2CSV algorithm and its implementation. The <italic>Evaluation and Results</italic> section defines the main criteria to evaluate the approach and details the results. The <italic>Discussion</italic> section discusses upon the achievements and propose a number of solutions for relaxing the two assumptions that we will be part of future development. The <italic>Related Works</italic> section discusses relevant works. Finally, <italic>Conclusion and Outlook</italic> section concludes the work describing the main achievements and provide a road-map for future work.</p>
    </sec>
    <sec sec-type="Project description">
      <title>Project description</title>
      <sec sec-type="Study area description">
        <title>Study area description</title>
        <p>First, we briefly introduce the R2RML and RML ([R2]RML) mapping languages to the extent at which it concerns with our preliminary investigation (see (<xref ref-type="bibr" rid="B1433733">Das et al. 2012</xref>) and (<xref ref-type="bibr" rid="B1433031">Dimou et al. 2013</xref>) for a thorough knowledge and complete details of both languages). Then, we describe an example of using RML for both the forward and reverse processes. Finally, we set the main assumptions under which we analyze the reverse problem.</p>
        <p><bold>An R2RML and RML Overview.</bold> R2RML provides a declarative language for expressing customized mappings from relational database to RDF dataset, expressed in a structure and target vocabulary of the Engineer's mapping choice (<xref ref-type="bibr" rid="B1433733">Das et al. 2012</xref>). Based on the same principle, RML provides an extension for expressing customized mapping rules from heterogeneous data structures and serializations (such as CSV, XML JSON) to the RDF data model (<xref ref-type="bibr" rid="B1433031">Dimou et al. 2013</xref>). The set of mapping rules is provided as an <italic>R2[RML] Mapping Document</italic>. It is any document written in the Turtle RDF syntax that encode an [R2]RML <italic>mapping</italic>. The latter is a structure that consists of one or more <italic>triples maps</italic> that specify the rules for translating, for the case of a CSV data source, each record to zero or more RDF triples. Specifically, a <italic>triples map</italic> is represented by a resource that: (1) it must have exactly one <italic>logical source</italic> that points to the data source (of type CSV) that contains the data to be mapped to RDF triples; (2) it must have exactly one <italic>subject map</italic> that specifies how to generate a subject for each record of the logical source; and (3) it may have zero or more <italic>predicate-object-maps</italic> that specifies pairs of predicate maps and object maps that, together with the subject generated by the subject map, may form one or more RDF triples for each record of the (CSV) data source (<xref ref-type="bibr" rid="B1433733">Das et al. 2012</xref>).</p>
        <p>To face with the high expressivity of RML's mapping language and to monitor the complexity of the <italic>reverse process</italic>, we have finalised, implementation included, the current work considering a subset of RML: RML Lite. The main restrictions that RML Lite imposes to a triples map are:</p>
        <p>1. given a mapping rule tm<sub>i</sub>, the <italic>subject map</italic> is characterized by one template property and one class property with IRIs values,</p>
        <p>2. given a mapping rule tm<sub>i</sub>, the <italic>predicate-object-Map</italic> references to one <italic>predicate property</italic> with IRI value and one <italic>object map</italic> which, in turn, is represented by an <italic>objectMap property</italic> with one value of <italic>referencing object map</italic> type,</p>
        <p>3. given a mapping rule tm<sub>i</sub>, a <italic>referencing object map</italic> is represented by a resource that has exactly one <italic>parentTriplesMap property</italic> where the value must be a triples maps as defined above, known as the referencing object map's parent triples map,</p>
        <p>4. if tm<sub>1</sub>,...,tm<sub>n</sub> are triples maps of the same RML Mapping Document and defined according to 1-3, they all refer to the same CSV data source.</p>
        <p>Basically, RML Lite allows only the mapping of CSV <italic>columns</italic> to <italic>Class</italic> or <italic>Object Property</italic> of an RDF data model and, at the same time, it is expressive enough to discuss potential issues related to the <italic>reverse process</italic> in general, and how we intend to approach them. An example of RML Lite Mapping document is showed in Fig. <xref ref-type="fig" rid="F1433266">1</xref>.</p>
        <p><bold>The CSV2RDF and RDF2CSV Processes.</bold> Generally speaking, mapping process aims at transforming instances of a data source structure into instances of target schema, preserving the semantic and allowing the implementation of an automatic algorithm to perform such a transformation (<xref ref-type="bibr" rid="B1432797">Kondylakis et al. 2006</xref>).</p>
        <p>When using RML to perform such a task for a CSV data source (CSV2RDF), it means to write down a set of rules (stored as [R2]RML <italic>mapping document</italic>) that specifies how to semantically interpret both the structure and the data with respect to the target RDF data model. For example, Fig. <xref ref-type="fig" rid="F1433266">1</xref> shows an example of RML mapping document with four rules: &lt;#Dataset&gt;, &lt;#Language&gt;, &lt;#SamplingActivity&gt; and &lt;#TimeSpan&gt;, where each rule declares how to transform the corresponding column and its values into RDF triples. For instance, the rule &lt;#Dataset&gt;, when applied, transforms the values of column datasetID into instances of the class: Dataset, e.g. &lt;4 rdf:type: Dataset&gt; and &lt;4 rdf:type: Dataset&gt;.</p>
        <p>Conversely, RDF2CSV - the task of rebuilding the structure and the instances of the CSV data source from the RDF dataset - works in opposite direction: the RML rules are used to rebuild the column-based structure and populate it with the data from the RDF dataset. To exemplify, the rule &lt;#Dataset&gt;, when applied for the reverse process, retransforms the instances of the class: Dataset into values of the column datasetID.</p>
        <p><bold>Assumptions.</bold> The RDF2CSV process can pose a number of issues making it a very challenging task to accomplish. In what follow we present and discuss two of them: the first is related to the set of RML mapping rules used to expose the CSV data source in RDF and, the second concerns with the <italic>implicit</italic> cardinality constraints of the associations between the columns of the CSV data source. For both, in this preliminary study, we formulate assumptions to work with.</p>
        <p><bold><italic>1. The Dependency Tree Assumption</italic>:</bold> It is related to the implicit structure that the set of RML mapping rules should form in order to succeed with the reverse process. Before formalizing it, we explain it by continuing the reverse of the RDF dataset of Fig. <xref ref-type="fig" rid="F1433266">1</xref>. Specifically, the rule &lt;#Language&gt; tell us that the instances of the class: Language are the values of the column language. Likewise, the rules &lt;#SamplingActivity&gt; and &lt;#TimeSpan&gt; would produce structure and data for the samplingID and the eventData columns, respectively. The result is showed in Fig. <xref ref-type="fig" rid="F1433270">2</xref>.</p>
        <p>What we have produced so far are only two dimensions (the columns and the cells) out of the three (the columns, the cells and the rows) that characterize a CSV data model. <xref ref-type="bibr" rid="B1432779">Tennison and Kellogg 2015</xref> defines a CSV in such a way that, for each row, the associated cells are (implicitly) kept together by including them in the same line. This is not the case for the RDF data model. Actually, the corresponding RDF triples may not be connected practically and, the RDF data model does not keep any specific order or relationship between them (<xref ref-type="bibr" rid="B1432945">Stefanova and Risch 2013b</xref>). Therefore, it is very difficult, or even impossible, to automatically decide whether the triple &lt;4, rdfs:type,: Dataset&gt; is associated with the triple &lt;English, rdfs:type,: Language&gt; or &lt;Greek, rdfs:type,: Language&gt; when reversing. This state of affair poses the issue of how to combine the values of the above four columns for building back the rows of the original CSV. In other words, how do we interrelate the cell values of columns? Concretely, how should we know whether 5 is related to Greek or English, when rebuilding the first row of the CSV source. The issue extends to the values of the other columns as well.</p>
        <p>We noticed that the root of this problem may lie in the fact that potential relationships between columns in the CSV data source are not expressed at the conceptual level through the mapping rules. As shown in Fig. <xref ref-type="fig" rid="F1540370">3</xref>, making such associations explicitly (see RML mapping rules of Fig. <xref ref-type="fig" rid="F1540370">3</xref>) would produce additional triples that materialize the links among the values of the same row. Specifically, we would know that 4 is connected to English and not with Greek through the triples &lt;4: hasLanguage English&gt;. Likewise, 4 is associated with R500 through the triple &lt;4: consistsOf R500&gt;, which in turn, is related to 26-09-2010 through the triple &lt;R500: hasTimeSpan 26-09-2010&gt;.</p>
        <p>Based on such observation, we asked how we can make sure that we deal with types of scenario exemplified in Fig. <xref ref-type="fig" rid="F1540370">3</xref> for which we would produce the expected result, and not with ones of Fig. <xref ref-type="fig" rid="F1433266">1</xref>. To achieve this, we analyzed the structure underlying the RML mapping rules for both cases. In particular, we can schematize such a dependency as a <italic>direct graph</italic> where the <italic>vertices</italic> are the Subjects' part of each rule and the <italic>edges</italic> are their PredicateObjectMaps' part. Fig. <xref ref-type="fig" rid="F1540538">4</xref> shows the two graphs, Graph 1 and Graph 2, obtained from the rules of the Figs <xref ref-type="fig" rid="F1433266">1</xref>, <xref ref-type="fig" rid="F1540370">3</xref>, respectively. As a result, we observed that the RML rules of Fig. <xref ref-type="fig" rid="F1433266">1</xref>, without formalizing the relationships between columns, form a graph with no edges (see Fig. <xref ref-type="fig" rid="F1540538">4</xref>, Graph 1) and, the rules of Fig. <xref ref-type="fig" rid="F1540370">3</xref>, that they do, form a directed graph forming an n-ary tree (see Fig. <xref ref-type="fig" rid="F1540538">4</xref>, Graph 2). Thus, in this paper we make a specific assumption on the graph structure underlying the mapping rules. It is expressed by the following <italic>Dependency Tree Assumption</italic>:</p>
        <p><bold>Dependency Tree Assumption (DTA).</bold> <italic>Given a set of RML mapping rules, S = {tm<sub>1</sub>,.. . , tm<sub><italic>n</italic></sub>}, that was used to expose a CSV data source, C, as an RDF dataset D. We use S over D to obtain back C if and only if the directed graph, G, underlying S is one n-ary tree.</italic></p>
        <p>Informally, G will have (a) only one vertice, <italic>root</italic>, that does not have incoming edges, (b) one or more vertices, <italic>leaves</italic>, that do not have outgoing edges, (c) there is at most one path (always starting from the <italic>root</italic> node) that connects two nodes and (d) each node has no more than n children.</p>
        <p><bold><italic>2. Implicit Cardinality Restrictions (ICR).</italic></bold> It is related to the cardinality of the association between CSV columns. For the sake of clarification, let's consider the example of Fig. <xref ref-type="fig" rid="F1540662">5</xref>. The CSV data source contains a number of rows that share the same values, making the relationships: consistsOf,: hasLanguage and: hasTimeSpan of cardinality 1:n. Under such a circumstance we face the issue of multiples range values for the same domain value. For example, &lt;4&gt; has two range values, &lt;R500&gt; and &lt;R501&gt;, through the predicate: consistsOf, and &lt;R500&gt; has also two associated values, &lt;26-09-2010&gt; and &lt;27-09-2010&gt;, through the predicate: hasTimeSpan. When reversing, it becomes problematic to decide which one of the pairs &lt;R500, 26-09-2010&gt; or &lt;R500, 27-09-2010&gt; should be used with the pair &lt;4, French&gt; in order to rebuild the row 2. Likewise for the reconstruction of the row 1. Currently, RDF Data Model does not provide the equivalent concept of "row" for keeping together RDF triples that refer to subparts of the same row (<xref ref-type="bibr" rid="B1432945">Stefanova and Risch 2013a</xref>), expect the notion of "reification" that can be used to support descriptions of a triple or set of triples (<xref ref-type="bibr" rid="B1540719">Grewe 2010</xref>). But it is currently not supported by [R2]RML. For the time being, to copy with such a complexity we make a specific assumption on the instance level of the original CSV data source, expressed as follows:</p>
        <p><bold>Implicit Cardinality Restrictions (ICR)</bold>. <italic>Given an RDF dataset D, we assume that D was generated from an original CSV data source C with associations between columns with only 0:0 or 1:1 cardinality constraints.</italic></p>
        <p>An example of CSV data source that satisfies the ICR assumption is showed in Fig. <xref ref-type="fig" rid="F1540370">3</xref>. We will proceed with the design of the RML2CSV algorithm assuming that both the DTA and ICR are satisfied.</p>
      </sec>
      <sec sec-type="Design description">
        <title>Design description</title>
        <p>Once the DTA and ICR are satisfied, the set of RML rules contains all the required information to rebuild the content, row by row, header included. In particular, each rule provides details such as the SubjectMap and PredicateObjectMap that connects two rules (e.g the predicate: consistsOf connects &lt;#Dataset&gt; with &lt;#SamplingActivity&gt;). Taking advantage of such structures, one way to build back a specific row is to exploit the set of rules from the most generic one to the most specific ones. Using a tree nomenclature, it means to visit the n-ary tree from the root to the leaves. We repeat this step for all the values that are instances of the root SubjectMap's Class. To exemplify the main idea, let us consider the RDF dataset and the set of rules of Fig. <xref ref-type="fig" rid="F1540370">3</xref>. It contains &lt;#Dataset&gt; as the most generic rule, whom SubjectMap's class is: Dataset and &lt;#TimeSpan&gt; and &lt;#Language&gt; as the most specific ones. The instances of: Dataset are &lt;4&gt; and &lt;5&gt;. Starting with &lt;4&gt;, we have that &lt;4&gt; is related to &lt;English&gt; through the predicate: hasLanguage (see the RDF triple &lt;4,: hasLanguage, English&gt; in the RDF dataset) and to &lt;R500&gt; through the predicate: consistsOf (see the RDF triple &lt;4,: consistsOf, R500&gt; in the RDF dataset), which, in turn, is related to &lt;26-09-2010&gt; through the predicate: hasTimeSpan (see the RDF triple &lt;R500,: hasTimeSpan, 26-09-2010&gt; in the RDF dataset). Organizing such values according to the structural information provided by the RML rules we build a row putting together the associated values, e.g. &lt;datasetID@4, language@English, samplingID@R500, eventDate@26-09-2010&gt;<ext-link ext-link-type="uri" xlink:href="mailto:eventDate@26-09-15">.</ext-link> Likewise for the value &lt;5&gt; we obtain the info of the second row: &lt;datasetID@5, language@Greek, samplingID@R300<ext-link ext-link-type="uri" xlink:href="mailto:samplingID@RS300">,</ext-link> eventDate@07-05-2011&gt;. As a result, we have all the required information to rebuild the CSV data source of Fig. <xref ref-type="fig" rid="F1540370">3</xref>.</p>
        <p>
          <bold>Algorithm</bold>
        </p>
        <p>To compute automatically such a process we devised a <italic>generic</italic> (as it provides the main steps that can be used also for other types of sources such as XML, JSON, DB) and <italic>extendible</italic> (as it provides the main logic for covering other RML language features as well as) algorithm, RML2CSV, as detailed in Algorithm 1. In particular, line 3 identifies the most generic triple map (it is the one that does not have any incoming edge) and line 4 retrieves the instances of the SubjectMap class of that triple map by using the <italic>SelectDistinctSubejct(classURI, d)</italic> function. The latter is based on the SPARQL query saves as <italic>PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; Select distinct ?subject Where { ?subject rdf:type classURI }</italic> executed over the RDF dataset. Finally, we use the set of RML rules to reconstruct all the rows (from line 5 to line 9) using the <italic>ReverseRow</italic> sub-call as reported in the Appendix. Once all the rows are reconstructed, line 10 exports and save them as csv file.</p>
        <p><bold>Algorithm 1.</bold> Reversing an RDF Dataset through the use of RML mapping rules.</p>
        <p>INPUT: 1) a set of RML mapping rules S 2) an RDF Dataset d.</p>
        <p>OUTPUT: 1) a CSV file.</p>
<p>1:  procedure RML2CSV (S, d)</p>
<p>2:   reversedCSV[] ← empty;                                                  //List  of reversed  rows.</p>
<p>3:      dT ← IdentifyTheMostGenericRMLrule(S);                               //dT  ← the root  node.      </p>
<p>4:      distinctSubjects[] ← SelectDistinctSubject(dt.getClassURI(), d);      </p>
<p>5:      for each subji in distinctSubjects[] do</p>
<p>6:            partRevRowi [] ← empty;                                        //List  of rowItem.</p>
<p>7:            currPred ← empty;                                              //a predicate of an RDF triple.</p>
<p>8:            reversedRowi[] ← ReverseRow(S, subji , partRevRowi[], currPred, dT, d);</p>
<p>9:            reversedCSV[].add(ReversedRowi[]);</p>
<p>10:     Export reversedCSV[] as a csv text file.</p>
      </sec>
      <sec sec-type="Funding">
        <title>Funding</title>
        <p>The work has been supported by the LifeWatchGreece project, funded by GSRT, ESFRI Research Infrastructures, Structural Funds, OPCE II (Act Code: 384676).</p>
      </sec>
    </sec>
    <sec sec-type="Web location (URIs)">
      <title>Web location (URIs)</title>
      <p>Download page: <ext-link ext-link-type="uri" xlink:href="https://bitbucket.org/carloallocca/rml2csv">https://bitbucket.org/carloallocca/rml2csv</ext-link></p>
    </sec>
    <sec sec-type="Technical specification">
      <title>Technical specification</title>
      <p>Programming language: Java</p>
      <p>Operational system: Windows or Linux or Mac</p>
      <p>Interface language: Java</p>
    </sec>
    <sec sec-type="Repository">
      <title>Repository</title>
      <p>Type: Git</p>
      <p>Browse URI: <ext-link ext-link-type="uri" xlink:href="https://bitbucket.org/carloallocca/rml2csv">https://bitbucket.org/carloallocca/rml2csv</ext-link></p>
      <p>Module: packages gr.hcmr.imbbc.rmlreverse.</p>
    </sec>
    <sec sec-type="Usage rights">
      <title>Usage rights</title>
      <sec sec-type="Use license">
        <title>Use license</title>
        <p>Creative Commons CCZero</p>
      </sec>
    </sec>
    <sec sec-type="Implementation">
      <title>Implementation</title>
      <sec sec-type="Implements specification">
        <title>Implements specification</title>
        <p>We have implemented RML2CSV on top of RML, based on the fact that, in comparison to the other approaches, it provides a uniform way to access different types of data sources such as CSV, XML, JSON and DB. Consequently, we believe that enabling the corresponding reverse processes within the same framework it would not only strengthen the latter but also make it to be used by a much larger community, as well as to extend it to support other type of data source, beyond CSV. The current implementation of the RML2CSV can be found at <ext-link ext-link-type="uri" xlink:href="https://bitbucket.org/carloallocca/rml2csv">https://bitbucket.org/carloallocca/rml2csv</ext-link> (see the three packages). It is important to highlight that the extension from RML Lite to RML does not have any logical implication on the presented algorithm. Moreover, we are currently working on it in order to cover the entire RML Mapping Language.</p>
      </sec>
    </sec>
    <sec sec-type="Additional information">
      <title>Additional information</title>
      <sec sec-type="Evaluation and Results">
        <title>Evaluation and Results</title>
        <p>The general goal of evaluating RML2CSV is to answer the following (related) questions: 1. Does it solve the problem that is supposed to? 2. Does it work correctly under all the assumptions? To answer such questions, we designed a set of content based criteria to estimate the extent to which the reversed data source (csv<sup>r</sup>) overlaps, row by row, with the original one (csv<sup>o</sup>). To this end, we based such a comparison on computing a similarity measure between csv<sup>r</sup> and csv<sup>o</sup>, as expressed in the following:</p>
        <p>
          <tex-math id="M1"><![CDATA[\documentclass[12pt]{standalone}
\usepackage{varwidth}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage{amsmath, amssymb, graphics, setspace}
\newcommand{\mathsym}[1]{{}}
\newcommand{\unicode}[1]{{}}
\newcounter{mathematicapage}
\begin{document}
   \begin{varwidth}{50in}
        \begin{equation*}
            ContentSimilarity(csv^{r}, csv^{o}) = 1 - contentDistance(csv^{r}, csv^{o}) \hspace{10mm}(1)
        \end{equation*}
    \end{varwidth}
\end{document}
]]></tex-math>
        </p>
        <p>where the contentDistance intends to measure the number of rows and the extent to which they contain the same information. It is defined as in the following:</p>
        <p>
          <tex-math id="M2"><![CDATA[\documentclass[12pt]{standalone}
\usepackage{varwidth}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage{amsmath, amssymb, graphics, setspace}
\newcommand{\mathsym}[1]{{}}
\newcommand{\unicode}[1]{{}}
\newcounter{mathematicapage}
\begin{document}
   \begin{varwidth}{50in}
        \begin{equation*}
            contentDistance(csv^{r}, csv^{o})= \sum\limits_{i=1}^m \frac{1}{m} \times rowDistance(row_{i}^{o}, row_{i}^{r}) \hspace{10mm}(2)
        \end{equation*}
    \end{varwidth}
\end{document}
]]></tex-math>
        </p>
        <p>where m is the number of rows of the csv<sup>o</sup>, row<sub>i</sub><sup>r </sup>is computed by CorrRow(row<sub>i</sub><sup>o</sup>) which is a function to calculate the corresponding i-th row in the reversed CSV and, the rowDistance measures the number of cells and the extent to which they contain the same values. It is defined as in the following:</p>
        <p>
          <tex-math id="M3"><![CDATA[\documentclass[12pt]{standalone}
\usepackage{varwidth}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage{amsmath, amssymb, graphics, setspace}
\newcommand{\mathsym}[1]{{}}
\newcommand{\unicode}[1]{{}}
\newcounter{mathematicapage}
\begin{document}
   \begin{varwidth}{50in}
        \begin{equation*}
            rowDistance(row_{i}^{o}, row_{i}^{r}) = \sum\limits_{i=1}^n \frac{1}{n} \times cellDistance(cell_{i}^{o}, cell_{i}^{r}) \hspace{17mm}(3)
        \end{equation*}
    \end{varwidth}
\end{document}
]]></tex-math>
        </p>
        <p>where n is the length of row<sub>i</sub><sup>o </sup>, cells<sub>i</sub><sup>r</sup> is computed by CellRow(cell<sub>i</sub><sup>o</sup>) which is a function to calculate the corresponding i-th cell in the reversed CSV  and the <italic>cellDistance</italic> is based on a string compare function checking whether the reversed value is the same as of the original one. Thus, <italic>cellDistance = 1</italic>, it means that the two values are different whereas <italic>cellDistance = 0</italic>  means that the two value are syntactically equal.</p>
        <p>Combining (1), (2) and (3) together we have that: if (3) is always equal to 0, meaning that anytime we compare two rows they always contain the same values, then (2) is equal 0, meaning that csv<sup>r</sup> and csv<sup>o</sup> contain the same content. In this case, (1) would measure a similarity equal to 1. On the contrary, if (3) is always equal to 1, meaning that anytime we compare two rows they always contain different values, then (2) is equal 1, meaning that csv<sup>r</sup> and csv<sup>o</sup> contain different content. In this case, (1) would measure a similarity equal to 0. To face with the</p>
        <p>The current evaluation is based on a collection of five CSV data sources from Biodiversity domain, containing mainly occurrence data from the MedOBIS (Biogeographic information system for the eastern Mediterranean and Black Sea (Arvanitidis et al. 2006)). They are characterized by a different column-based structure containing from 4 to 12 columns (e.g. datasetID, language, fieldNumber, different types of measurements just to report a few). Before transforming them into RDF datasets we applied a pre-preprocessing to make sure that their content would not generate any of the issues analyzed in the <italic>Study Area Description</italic> section and further analyzed in the <italic>Discussion</italic> section. After running RML2CSV we compared csv<sup>r</sup> and csv<sup>o</sup> according to the criteria (1), (2) and (3). The results are shown in Fig. <xref ref-type="fig" rid="F1600992">6</xref>.</p>
        <p>As it can be noticed, RML2CSV reconstructed all the five CSVs with a content up to 100% overlapped with the original ones. This very initial evaluation does not pretend to demonstrate the correctness or completeness of proposed approach, but it posed the base and encourage us for a thorough evaluation of the RML2CSV efficiency and effectiveness.</p>
      </sec>
      <sec sec-type="Discussion">
        <title>Discussion</title>
        <p>We designed and implemented our algorithm, RML2CSV, taking into account the DTA and the ICR assumptions. Now, we discuss how to build upon the current achievemnts in order to suggest solutions for relaxing the two assumptions.</p>
        <p><bold>More about the DTA and ICR:</bold> Being aware that they could be too limited for dealing with a wide range of real cases, we propose two solutions for relaxing the two assumptions. The first is based on extending the forward process producing an auxiliary structure for keeping links between RDF triples that refer to the subparts of the same row. Fig. <xref ref-type="fig" rid="F1433327">7</xref> shows an approach based on a quad (instead of triple) structure where the fourth component describes the row that the triples are connected to. This would mean to change the workflow of the entire forward process of RML. The second, that is the one we consider in the next developments, is based on the only and more realistic assumption that the CSV data source should have a structure containing at least one column with unique value that could be used as <italic>key.</italic> Based on this, the RML rules could be extended with an appropriate and domain independent relationship for keeping links between RDF triples that refer to the subparts of the same row, through the use of such ''key column''. Fig. <xref ref-type="fig" rid="F1600994">9</xref> shows an example where <italic>rowNumber</italic> exemplifies the role of a key-column of the CSV data source. And, in order to keep the link between the different values of the same row we extended each RML rule with an PredicateObjectMap that uses the predicate: hasIdentifier which, in turn, refers to &lt;\#RowNumber&gt; rule. By doing so, the forward process generates triples such as &lt;4, rdf:type,: Dataset&gt;, &lt;4,: hasIdentifier, 287&gt;, &lt;$English,: hasIdentifier, 287&gt; and &lt;ka\_la\_2002,: hasIdentifier, 287&gt; that will indeed support the reverse process to distinguish the values of the row 287 from those of the row 285. In this way the issue of having associations of cardinality 1:n, or more in general m:n, would be solved.</p>
        <p>​<bold>Mapping Quality Level:</bold> Fig. <xref ref-type="fig" rid="F1433329">8</xref> shows a case of interpreting two different columns, homeAddress and officeAddress, with the same predicate: hasAddress whom parentTripleMap refers to two different RML rules which, in turn, have the same URI resource for the corresponding SubjectMap class. In this case, it would be difficult to decide the home and the office address of &lt;4&gt; when reversing, as both &lt;Via Naples, Roma, Italy&gt; and &lt;Via Roma, Naples, Italy&gt; are related to &lt;4&gt; through the same predicate: hasAddress. Another similar example could be that not all the data of the original CSV are mapped or heavy post-processing (e.g. transforming latitude, longitude and coordinateUncertaintyInMeters in a polygon) that can’t be inverted is applied. Such type of issues could be related, in one way or another, to the quality of mapping rules. In other words, a very “<italic>high</italic> ”, in quality, mapping rule set would avoid the above issues, whereas a very “<italic>low</italic> ”, in quality, mapping rule set would generate not only the one discussed above but also others that have not been considered yet. As we are moving out of the scope of the current work, for such type of issues we will rely on the mapping quality outcomes (<xref ref-type="bibr" rid="B1432374">Dimou et al. 2014</xref>), setting new principles and guidelines for supporting the user on how and what to expose and, at the same time, delivering mapping services for checking the quality.</p>
      </sec>
      <sec sec-type="Related Work">
        <title>Related Work</title>
        <p>To the best of our knowledge, there is no other study investigating the reversing of an RDF dataset for reconstructing the original tabular data source of CSV type. On the contrary, several solutions exist to execute mappings from different types of data sources and serialisations to the RDF data model. The R2RML W3C recommendations (<xref ref-type="bibr" rid="B1433733">Das et al. 2012</xref>) and its direct extension RML (Dimou et al. 2013) are the two main approaches to expose different types of data sources as an RDF dataset. X3ML (Kondylakis et al. 2006) implements a similar declarative approach by providing an XML-based mapping language for consuming XML records and producing RDF in various serializations. Moreover, mapping languages were defined to support mapping for tabular data in CSV and spreadsheets to RDF. They include the XLWrap’s mapping language (<xref ref-type="bibr" rid="B1432997">Langegger and Wöß 2009</xref>) that converts data in various spreadsheets to RDF, the declarative OWL-centric mapping language Mapping Masters M2 (<xref ref-type="bibr" rid="B1432983">O’Connor et al. 2010</xref>) that converts data from spreadsheets into the Web Ontology Language (OWL), and Vertere (<ext-link ext-link-type="uri" xlink:href="https://github.com/knudmoeller/Vertere-RDF">https://github.com/knudmoeller/Vertere-RDF</ext-link>). Furthermore, there were other solutions proposed for mappings of data in tabular structure to the RDF data model but in those solutions the mapping solutions are tiedto the implementation (a complete list can be found at <ext-link ext-link-type="uri" xlink:href="http://www.w3.org/wiki/ConverterToRdf">http://www.w3.org/wiki/ConverterToRdf</ext-link>). Overall, none of these solutions considered the reverse mapping, namely from the generated RDF dataset to the original tabular data source. Except for a few cases dealing with rebuilding Database schema and instances from RDF documents).</p>
        <p>In particular, <ext-link ext-link-type="uri" xlink:href="http://www.w3.org/wiki/ConverterToRdf">RDF2RDB</ext-link> (<xref ref-type="bibr" rid="B1432844">Teswanich and Chittayasothorn 2007</xref>)provides an approach to transform an RDF document into RDB. Under the assumption that an RDF document - not defined in the corresponding paper- is equivalent to the RDF dataset as used in this paper, one could think of using RDF2RDB for reconstructing the CSV file by storing the RDF dataset in one RDB table and then export it as CSV file. Unfortunately, the approach does not work to achieve the reconstruction of the CSV data source according to the original structure. Let us explain why: The use of RML mapping rules to transform a CSV data source in RDF dataset is based on a target schema or vocabulary that is chosen by the mapping creator. One of the consequences of that is that the original CSV structure may be completely destroyed (e.g. eventData become TimeSpan, see Fig 1.). Therefore, the application of RDF2RDB would produce a single table, ready to be exported as CSV, that reflects the used target schema or vocabulary. In contrast, our work aimed at rebuilding the CSV according to its original structure.</p>
        <p>Similarly (<xref ref-type="bibr" rid="B1432955">Stefanova and Risch 2013a</xref>) and (<xref ref-type="bibr" rid="B1432945">Stefanova and Risch 2013b</xref>) present SAQ- Semantic Archive and Query - a system for recreating of relational database archived as RDF dataset. Once again, one could consider to use SAQ for performing the forward and the backward transactions. Accordingly, there is very high price to pay which is based on the fact that the RDB to RDF mapping is based on the direct mapping (<xref ref-type="bibr" rid="B1601020">Arenas et al. 2012</xref>) where the structure of the result RDF dataset directly reflects the RDB schema elements. In other words, There is a direct correspondence between the target RDF vocabulary and the names of the RDB schema elements. In contrast, RML2CSV is built on top of RML that provides a mapping language for expressing customized mappings from a heterogeneous data source to an RDF data model that does not necessary reflect the original structure as showed above. <ext-link ext-link-type="uri" xlink:href="http://www.w3.org/wiki/ConverterToRdf">R2D</ext-link> (<xref ref-type="bibr" rid="B1432807">Ramanujam et al. 2009a</xref>, <xref ref-type="bibr" rid="B1432833">Ramanujam et al. 2009b</xref>) generates a relational view through the execution of SQL queries over an RDF store. Similarly to Jena (<xref ref-type="bibr" rid="B1432339">HPCompany and F. 2002</xref>) through the use of the service TupleQueryResultFormat allowing to format the query results in a number of ways, including CSV, JSON and so on. But they don't do it according to the original schema. Finally, (<xref ref-type="bibr" rid="B1433061">Terwilliger et al. 2008</xref>) and (<xref ref-type="bibr" rid="B1432788">Drew 2014</xref>) face the problem of converting XML, and not RDF, Schema to relation tables.</p>
        <p>Unfortunately, all these existing approaches are rather limited for our scenario either because they do not consider the reverse problem at all or because they face it in different context and targetting diverse goal. While they contribute interesting elements for us to build on, we focus here on how to perform the reverse process for the case of column-based structured data source of CSV type w.r.t its original data structure and not any. Furthermore, as our solution is based on [R2]RML mapping language, it provides the additional advantage that we can perform both transactions, CSV data source to RDF dataset and vice-versa, within the same framework, that none of the discussed work does.</p>
      </sec>
      <sec sec-type="Conclusion and Outlook">
        <title>Conclusion and Outlook</title>
        <p>In this paper we argue that an important aspect of long-term preservation of digital objects, such RDF datasets, is to provide full support for reusing such data, including mechanisms to bring back the data to their original format. To achieve this, in this work we investigated on how to perform the reverse process for the case of column-based data source such as tabular data. In particular, we devised an algorithm, the RML2CSV, for transforming an RDF dataset into its original data structure, through the use of the same RML mapping rules used to generate the set of RDF triples. The results of the evaluation showed that RML2CSV rebuilds the same data content with the same data structure under certain assumptions.</p>
        <p>In the future, a thorough evaluation of RML2CSV efficiency will be performed. In addition, we have planned to extend RML2CSV to dealwith any type of constraints between columns (e.g. 1:n and, more general m:m) as discussed in <italic>Discussion</italic> section and to cover all RML mapping languages. As a long term objective, we plan to design and implement the back transformation to any type of relevant formats including XML, JSON and DB, by taking advantage of the achievements presented in this paper.</p>
        <p>
          <bold>Appendix.</bold>
        </p>
        <p>Algorithm 2 Reversing a single CSV row from an RDF Dataset through the use of RML mappings.</p>
<p>1: procedure ReverseRow(subji, partRevRowi [], currP red, dT, d)</p>
<p>2:   currentRowContent[] ← partRevRowi [];</p>
<p>3:   if  dT = null then</p>
<p>4:      currSubjectValue ← subji;</p>
<p>5:      if  dT.PredicateObjectMaps[] = null ∧ dT is not  the root node  then</p>
<p>6:          return currentRowContent[];</p>
<p>7:      if  dT.PredicateObjectMaps[] = null ∧ dT is the root node  then</p>
<p>8:          termName ← dT.SubjectMap.getTemplate.localName;     </p>
<p>              . we need to check if SubjectMap has a template</p>
<p>9:          rowItem ← TermName@currSubjectValue;</p>
<p>10:         currentRowContent[].add(rowItem);</p>
<p>11:         return currentRowContent[];</p>
<p>12:     else</p>
<p>13:        for  i = 1 to dT .P redicateObjectM aps[].length do</p>
<p>14:          currP red ← dT.PredicateObjectMap[i].getPredicate;</p>
<p>15:          objectMap ← dT.PredicateObjectMap[i].getObjectMap;</p>
<p>16:          if  objectMap contains a parentTripleMap  then</p>
<p>17:              parentTriplesMap ← objectMap.getParentTriplesMap();</p>
<p>18:              tripleMapName ← parentTriplesMap.getName();</p>
<p>19:              nextTripleMap ← Search(dT, tripleMapName);</p>
<p>20:              termName ← nextTripleMap.SubjectMap.getTemplate.localName;     </p>
<p>                   . we need to check if SubjectMap has a template</p>
<p>21:              className ← nextNodeToExplore.SubjectMap.getClass;</p>
<p>22:              nextSubject ← SelectDistinctObject(d, currSubjectValue, currPred, className);     </p>
<p>                   . SPARQL query where (currSubjectValue, currPred, ?object) and (?object rdf:type className)</p>
<p>23:              cellItem ← termName@nextSubject;</p>
<p>24:              currentRowContent[].add(cellItem);</p>
<p>25:              ReverseRow(nextSubject, currentRowContent[], currPred, nextTripleMap, d);</p>
<p>26:              if  dT is the root  then</p>
<p>27:                  termName ← dT.SubjectMap.getTemplate.localName;</p>
<p>28:                  rowItem ← termName@subji;</p>
<p>29:                  currentRowContent[].add(rowItem);     </p>
<p>                       . if it is not already added</p>
<p>30:           if  objectMap contains a rr:reference  then</p>
<p>31:               print(”Not detailed for space reason.”);</p>
<p>32:           return currentRowContent[];</p>
<p>33:    else return null;</p>
      </sec>
    </sec>
  </body>
  <back>
    <ack>
      <title>Acknowledgements</title>
      <p>The authors would like to thank Nicolas Bailly for fruitful discussions and for providing valuable input to the issues of this article and Anastasia Dimou for contributing tremendously to the paper even though declining co-authorship. This research has been supported by LifeWatchGreece project (Funded by GSRT, EFRI Projects, Structural Funds, OPCE II).</p>
    </ack>
    <ref-list>
      <title>References</title>
      <ref id="B1601020">
        <element-citation publication-type="website">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Arenas</surname>
              <given-names>Marcelo</given-names>
            </name>
            <name name-style="western">
              <surname>Bertails</surname>
              <given-names>Alexandre</given-names>
            </name>
            <name name-style="western">
              <surname>Prud'hommeaux</surname>
              <given-names>Eric</given-names>
            </name>
            <name name-style="western">
              <surname>Sequeda</surname>
              <given-names>Juan</given-names>
            </name>
          </person-group>
          <article-title>A Direct Mapping of Relational Data to RDF</article-title>
          <uri>http://www.w3.org/TR/rdb-direct-mapping/</uri>
          <date-in-citation content-type="access-date">2015-05-15T00:00:00+03:00</date-in-citation>
        </element-citation>
      </ref>
      <ref id="B1432965">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Arvanitidis</surname>
              <given-names>C.</given-names>
            </name>
            <name name-style="western">
              <surname>Valavanis</surname>
              <given-names>V. D.</given-names>
            </name>
            <name name-style="western">
              <surname>Eleftheriou</surname>
              <given-names>A.</given-names>
            </name>
            <name name-style="western">
              <surname>Costello</surname>
              <given-names>M. J.</given-names>
            </name>
            <name name-style="western">
              <surname>Faulwetter</surname>
              <given-names>S.</given-names>
            </name>
            <name name-style="western">
              <surname>Gotsis</surname>
              <given-names>P.</given-names>
            </name>
            <name name-style="western">
              <surname>Kitsos</surname>
              <given-names>M. S.</given-names>
            </name>
            <name name-style="western">
              <surname>Kirmtzoglou</surname>
              <given-names>I.</given-names>
            </name>
            <name name-style="western">
              <surname>Zenetos</surname>
              <given-names>A.</given-names>
            </name>
            <name name-style="western">
              <surname>Petrov</surname>
              <given-names>A.</given-names>
            </name>
            <name name-style="western">
              <surname>Galil</surname>
              <given-names>B.</given-names>
            </name>
            <name name-style="western">
              <surname>Papageorgiou</surname>
              <given-names>N.</given-names>
            </name>
          </person-group>
          <year>2006</year>
          <source>MedOBIS: Biogeographic information system for the eastern Mediterranean and Black Sea</source>
          <volume>316</volume>
          <conf-name>Marine Ecology Progress Series</conf-name>
          <size units="page">225-230</size>
        </element-citation>
      </ref>
      <ref id="B1433011">
        <element-citation publication-type="article">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Bizer</surname>
              <given-names>C.</given-names>
            </name>
            <name name-style="western">
              <surname>Heath</surname>
              <given-names>T.</given-names>
            </name>
            <name name-style="western">
              <surname>Berners-Lee</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <year>2009</year>
          <article-title>Linked Data - The Story So Far</article-title>
          <source>International Journal on Semantic Web and Information Systems</source>
          <volume>5</volume>
          <issue>3</issue>
          <fpage>1</fpage>
          <lpage>22</lpage>
          <uri>https://doi.org/10.4018/jswis.2009081901</uri>
          <pub-id pub-id-type="doi">10.4018/jswis.2009081901</pub-id>
        </element-citation>
      </ref>
      <ref id="B1432864">
        <element-citation publication-type="chapter">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Candela</surname>
              <given-names>L.</given-names>
            </name>
            <name name-style="western">
              <surname>Coro</surname>
              <given-names>G.</given-names>
            </name>
            <name name-style="western">
              <surname>Pagano</surname>
              <given-names>P.</given-names>
            </name>
          </person-group>
          <year>2013</year>
          <chapter-title>Supporting Tabular Data Characterization in a Large Scale Data Infrastructure by Lexical Matching Techniques</chapter-title>
          <source>Communications in Computer and Information Science</source>
          <uri>https://doi.org/10.1007/978-3-642-35834-0_5</uri>
          <pub-id pub-id-type="doi">10.1007/978-3-642-35834-0_5</pub-id>
        </element-citation>
      </ref>
      <ref id="B1433733">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Das</surname>
              <given-names>Souripriya</given-names>
            </name>
            <name name-style="western">
              <surname>Sundara</surname>
              <given-names>Seema</given-names>
            </name>
            <name name-style="western">
              <surname>Cyganiak</surname>
              <given-names>Richard</given-names>
            </name>
          </person-group>
          <year>2012</year>
          <source>R2RML: RDB to RDF Mapping Language</source>
          <conf-loc>W3C Recommendation 27 September 2012</conf-loc>
          <size units="page">25</size>
          <uri>http://www.w3.org/TR/r2rml/</uri>
        </element-citation>
      </ref>
      <ref id="B1432374">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Dimou</surname>
              <given-names>A.</given-names>
            </name>
            <name name-style="western">
              <surname>Sande</surname>
              <given-names>M. V.</given-names>
            </name>
            <name name-style="western">
              <surname>Nies</surname>
              <given-names>T. De</given-names>
            </name>
            <name name-style="western">
              <surname>Mannens</surname>
              <given-names>R.</given-names>
            </name>
            <name name-style="western">
              <surname>Walle</surname>
              <given-names>R. Van de</given-names>
            </name>
          </person-group>
          <year>2014</year>
          <source>RDF Mapping Rules Refinements According to Data Consumers' Feedback</source>
          <conf-name>WWW Companion</conf-name>
          <conf-loc>Proceedings of the Companion Publication of the 23rd International Conference on World Wide Web Companion</conf-loc>
          <size units="page">249-250</size>
        </element-citation>
      </ref>
      <ref id="B1433031">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Dimou</surname>
              <given-names>A.</given-names>
            </name>
            <name name-style="western">
              <surname>Vander</surname>
              <given-names>M. S.</given-names>
            </name>
            <name name-style="western">
              <surname>Colpaert</surname>
              <given-names>P.</given-names>
            </name>
            <name name-style="western">
              <surname>Mannens</surname>
              <given-names>E.</given-names>
            </name>
            <name name-style="western">
              <surname>Walle</surname>
              <given-names>R. Van de</given-names>
            </name>
          </person-group>
          <year>2013</year>
          <source>Extending R2RML to a source-independent mapping language for RDF</source>
          <conf-loc>In Proceedings of the International Semantic Web Conference</conf-loc>
          <conf-date>Sydney, Australie</conf-date>
          <size units="page">237-240</size>
        </element-citation>
      </ref>
      <ref id="B1432788">
        <element-citation publication-type="book">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Drew</surname>
              <given-names>A.</given-names>
            </name>
          </person-group>
          <year>2014</year>
          <source>Oracle XML DB Developer's Guide, 11<italic>g</italic> Release 2 (11.2)</source>
          <publisher-name>Oracle and/or its affiliates. All rights reserved.</publisher-name>
          <size units="page">54</size>
        </element-citation>
      </ref>
      <ref id="B1432364">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Flouris</surname>
              <given-names>G.</given-names>
            </name>
            <name name-style="western">
              <surname>Meghini</surname>
              <given-names>C.</given-names>
            </name>
          </person-group>
          <year>2007</year>
          <source>Some Preliminary Ideas Towards a Theory of Digital Preservation</source>
          <conf-name>DLF1-07</conf-name>
          <conf-loc>In Proceedings of the 1st International Workshop on Digital Libraries Foundations</conf-loc>
          <size units="page">34</size>
        </element-citation>
      </ref>
      <ref id="B1540719">
        <element-citation publication-type="article">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Grewe</surname>
              <given-names>Niels</given-names>
            </name>
          </person-group>
          <year>2010</year>
          <article-title>A generic reification strategy for n-ary relations in DL.</article-title>
          <source>OBML 2010 Workshop Proceedings</source>
          <volume>24</volume>
          <fpage>67</fpage>
        </element-citation>
      </ref>
      <ref id="B1433021">
        <element-citation publication-type="article">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Heath</surname>
              <given-names>T.</given-names>
            </name>
            <name name-style="western">
              <surname>Bizer</surname>
              <given-names>C.</given-names>
            </name>
          </person-group>
          <year>2011</year>
          <article-title>Linked Data: Evolving the Web into a Global Data Space</article-title>
          <source>Synthesis Lectures on the Semantic Web: Theory and Technology</source>
          <volume>1</volume>
          <issue>1</issue>
          <fpage>1</fpage>
          <lpage>136</lpage>
          <uri>https://doi.org/10.2200/s00334ed1v01y201102wbe001</uri>
          <pub-id pub-id-type="doi">10.2200/s00334ed1v01y201102wbe001</pub-id>
        </element-citation>
      </ref>
      <ref id="B1432339">
        <element-citation publication-type="software">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>HPCompany</surname>
            </name>
            <name name-style="western">
              <surname>F.</surname>
              <given-names>Apache Software</given-names>
            </name>
          </person-group>
          <year>2002</year>
          <article-title>Jena - A Semantic Web Framework for Java.</article-title>
          <uri>http://jena.sourceforge.net/index.html</uri>
        </element-citation>
      </ref>
      <ref id="B1432892">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Kaschner</surname>
              <given-names>K.</given-names>
            </name>
            <name name-style="western">
              <surname>Ready</surname>
              <given-names>J. S.</given-names>
            </name>
            <name name-style="western">
              <surname>Agbayani</surname>
              <given-names>E.</given-names>
            </name>
            <name name-style="western">
              <surname>Rius</surname>
              <given-names>J.</given-names>
            </name>
            <name name-style="western">
              <surname>Kesner-Reyes</surname>
              <given-names>K.</given-names>
            </name>
            <name name-style="western">
              <surname>Eastwood</surname>
              <given-names>P. D.</given-names>
            </name>
            <name name-style="western">
              <surname>South</surname>
              <given-names>A. B.</given-names>
            </name>
            <name name-style="western">
              <surname>Kullander</surname>
              <given-names>S. O.</given-names>
            </name>
            <name name-style="western">
              <surname>Rees</surname>
              <given-names>T.</given-names>
            </name>
            <name name-style="western">
              <surname>Close</surname>
              <given-names>C. H.</given-names>
            </name>
            <name name-style="western">
              <surname>Watson</surname>
              <given-names>R.</given-names>
            </name>
            <name name-style="western">
              <surname>Pauly</surname>
              <given-names>D.</given-names>
            </name>
          </person-group>
          <year>2008</year>
          <source>AquaMaps: Predicted range maps for aquatic species</source>
          <conf-name>ACM</conf-name>
          <size units="page">12</size>
          <uri>http://www.aquamaps.org/</uri>
        </element-citation>
      </ref>
      <ref id="B1432797">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Kondylakis</surname>
              <given-names>H.</given-names>
            </name>
            <name name-style="western">
              <surname>Doerr</surname>
              <given-names>M.</given-names>
            </name>
            <name name-style="western">
              <surname>Plexousakis</surname>
              <given-names>D.</given-names>
            </name>
          </person-group>
          <year>2006</year>
          <source>Mapping Language for Information Integration</source>
          <conf-loc>Technical Report FORTH-ICS/TR-385.</conf-loc>
          <size units="page">15</size>
        </element-citation>
      </ref>
      <ref id="B1432997">
        <element-citation publication-type="chapter">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Langegger</surname>
              <given-names>A.</given-names>
            </name>
            <name name-style="western">
              <surname>Wöß</surname>
              <given-names>W.</given-names>
            </name>
          </person-group>
          <year>2009</year>
          <chapter-title>XLWrap – Querying and Integrating Arbitrary Spreadsheets with SPARQL</chapter-title>
          <source>Lecture Notes in Computer Science</source>
          <uri>https://doi.org/10.1007/978-3-642-04930-9_23</uri>
          <pub-id pub-id-type="doi">10.1007/978-3-642-04930-9_23</pub-id>
        </element-citation>
      </ref>
      <ref id="B1432983">
        <element-citation publication-type="chapter">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>O’Connor</surname>
              <given-names>M. J.</given-names>
            </name>
            <name name-style="western">
              <surname>Halaschek-Wiener</surname>
              <given-names>C.</given-names>
            </name>
            <name name-style="western">
              <surname>Musen</surname>
              <given-names>M. A.</given-names>
            </name>
          </person-group>
          <year>2010</year>
          <chapter-title>Mapping Master: A Flexible Approach for Mapping Spreadsheets to OWL</chapter-title>
          <source>Lecture Notes in Computer Science</source>
          <uri>https://doi.org/10.1007/978-3-642-17749-1_13</uri>
          <pub-id pub-id-type="doi">10.1007/978-3-642-17749-1_13</pub-id>
        </element-citation>
      </ref>
      <ref id="B1432807">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Ramanujam</surname>
              <given-names>S.</given-names>
            </name>
            <name name-style="western">
              <surname>Gupta</surname>
              <given-names>A.</given-names>
            </name>
            <name name-style="western">
              <surname>Khan</surname>
              <given-names>L.</given-names>
            </name>
            <name name-style="western">
              <surname>Seida</surname>
              <given-names>S.</given-names>
            </name>
            <name name-style="western">
              <surname>Thuraisingham</surname>
              <given-names>B.</given-names>
            </name>
          </person-group>
          <year>2009</year>
          <source>R2D: A bridge between the semantic web and relational visualization tools</source>
          <publisher-name>IEEE</publisher-name>
          <size units="page">303-311</size>
        </element-citation>
      </ref>
      <ref id="B1432833">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Ramanujam</surname>
              <given-names>S.</given-names>
            </name>
            <name name-style="western">
              <surname>Gupta</surname>
              <given-names>A.</given-names>
            </name>
            <name name-style="western">
              <surname>Khan</surname>
              <given-names>L.</given-names>
            </name>
            <name name-style="western">
              <surname>Seida</surname>
              <given-names>S.</given-names>
            </name>
            <name name-style="western">
              <surname>Thuraisingham</surname>
              <given-names>B.</given-names>
            </name>
          </person-group>
          <year>2009</year>
          <source>R2D: Extracting Relational Structure from RDF Stores</source>
          <publisher-name>2009 IEEE/WIC/ACM International Joint Conference on Web Intelligence and Intelligent Agent Technology</publisher-name>
          <size units="page">6</size>
          <uri>https://doi.org/10.1109/wi-iat.2009.63</uri>
          <pub-id pub-id-type="doi">10.1109/wi-iat.2009.63</pub-id>
        </element-citation>
      </ref>
      <ref id="B1432348">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Shaon</surname>
              <given-names>A.</given-names>
            </name>
            <name name-style="western">
              <surname>Giaretta</surname>
              <given-names>D.</given-names>
            </name>
            <name name-style="western">
              <surname>Conway</surname>
              <given-names>E.</given-names>
            </name>
            <name name-style="western">
              <surname>Matthews</surname>
              <given-names>B.</given-names>
            </name>
            <name name-style="western">
              <surname>Crompton</surname>
              <given-names>S.</given-names>
            </name>
            <name name-style="western">
              <surname>Yu</surname>
              <given-names>J.</given-names>
            </name>
            <name name-style="western">
              <surname>Marelli</surname>
              <given-names>F.</given-names>
            </name>
            <name name-style="western">
              <surname>Giammatteo</surname>
              <given-names>U. Di</given-names>
            </name>
            <name name-style="western">
              <surname>Marketakis</surname>
              <given-names>Y.</given-names>
            </name>
            <name name-style="western">
              <surname>Tzitzikas</surname>
              <given-names>Y.</given-names>
            </name>
          </person-group>
          <year>2012</year>
          <source>Towards a Long-term preservation infrastructure for earth science data</source>
          <conf-loc>Preservation of Digital Objects</conf-loc>
          <size units="page">89</size>
        </element-citation>
      </ref>
      <ref id="B1432945">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Stefanova</surname>
              <given-names>S.</given-names>
            </name>
            <name name-style="western">
              <surname>Risch</surname>
              <given-names>T.</given-names>
            </name>
          </person-group>
          <year>2013</year>
          <source>Scalable long-term preservation of relational data through SPARQL queries.</source>
          <conf-name>Semantic Web Journal</conf-name>
          <conf-loc>SWJ '13</conf-loc>
          <size units="page">15</size>
        </element-citation>
      </ref>
      <ref id="B1432955">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Stefanova</surname>
              <given-names>Silvia</given-names>
            </name>
            <name name-style="western">
              <surname>Risch</surname>
              <given-names>Tore</given-names>
            </name>
          </person-group>
          <year>2013</year>
          <source>Scalable Reconstruction of RDF-archived Relational Databases</source>
          <publisher-name>Proceedings of the Fifth Workshop on Semantic Web Information Management - SWIM '13</publisher-name>
          <size units="page">1-4</size>
          <uri>https://doi.org/10.1145/2484712.2484717</uri>
          <pub-id pub-id-type="doi">10.1145/2484712.2484717</pub-id>
        </element-citation>
      </ref>
      <ref id="B1432779">
        <element-citation publication-type="software">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Tennison</surname>
              <given-names>Jeni</given-names>
            </name>
            <name name-style="western">
              <surname>Kellogg</surname>
              <given-names>Gregg</given-names>
            </name>
          </person-group>
          <year>2015</year>
          <article-title>Model for Tabular Data and Metadata on the Web</article-title>
          <publisher-name>W3C Working Draft 08 January 2015</publisher-name>
          <uri>http://www.w3.org/TR/tabular-data-model/</uri>
        </element-citation>
      </ref>
      <ref id="B1433061">
        <element-citation publication-type="article">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Terwilliger</surname>
              <given-names>J. F.</given-names>
            </name>
            <name name-style="western">
              <surname>Melnik</surname>
              <given-names>S.</given-names>
            </name>
            <name name-style="western">
              <surname>Bernstein</surname>
              <given-names>P. A.</given-names>
            </name>
          </person-group>
          <year>2008</year>
          <article-title>Language-integrated querying of XML data in SQL server</article-title>
          <source>Proceedings of the VLDB Endowment</source>
          <volume>1</volume>
          <issue>2</issue>
          <fpage>1396</fpage>
          <lpage>1399</lpage>
          <uri>https://doi.org/10.14778/1454159.1454182</uri>
          <pub-id pub-id-type="doi">10.14778/1454159.1454182</pub-id>
        </element-citation>
      </ref>
      <ref id="B1432844">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Teswanich</surname>
              <given-names>W.</given-names>
            </name>
            <name name-style="western">
              <surname>Chittayasothorn</surname>
              <given-names>S.</given-names>
            </name>
          </person-group>
          <year>2007</year>
          <source>A Transformation from RDF Documents and Schemas to Relational Databases.</source>
          <publisher-name>2007 IEEE Pacific Rim Conference on Communications, Computers and Signal Processing</publisher-name>
          <size units="page">15</size>
          <uri>https://doi.org/10.1109/pacrim.2007.4313171</uri>
          <pub-id pub-id-type="doi">10.1109/pacrim.2007.4313171</pub-id>
        </element-citation>
      </ref>
      <ref id="B1432282">
        <element-citation publication-type="conference-preoceeding">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Tzitzikas</surname>
              <given-names>Y.</given-names>
            </name>
            <name name-style="western">
              <surname>Marketakis</surname>
              <given-names>Y.</given-names>
            </name>
            <name name-style="western">
              <surname>Kargakis</surname>
              <given-names>Y.</given-names>
            </name>
          </person-group>
          <year>2012</year>
          <source>Conversion and emulation-aware dependency reasoning for curation services</source>
          <conf-loc>Proc. 9th Int. Conference on Preservation of Digital Objects</conf-loc>
          <publisher-name>iPres2012</publisher-name>
          <size units="page">38-45</size>
        </element-citation>
      </ref>
      <ref id="B1433042">
        <element-citation publication-type="chapter">
          <person-group person-group-type="author">
            <name name-style="western">
              <surname>Tzitzikas</surname>
              <given-names>Y.</given-names>
            </name>
            <name name-style="western">
              <surname>Allocca</surname>
              <given-names>C.</given-names>
            </name>
            <name name-style="western">
              <surname>Bekiari</surname>
              <given-names>C.</given-names>
            </name>
            <name name-style="western">
              <surname>Marketakis</surname>
              <given-names>Y.</given-names>
            </name>
            <name name-style="western">
              <surname>Fafalios</surname>
              <given-names>P.</given-names>
            </name>
            <name name-style="western">
              <surname>Doerr</surname>
              <given-names>M.</given-names>
            </name>
            <name name-style="western">
              <surname>Minadakis</surname>
              <given-names>N.</given-names>
            </name>
            <name name-style="western">
              <surname>Patkos</surname>
              <given-names>T.</given-names>
            </name>
            <name name-style="western">
              <surname>Candela</surname>
              <given-names>L.</given-names>
            </name>
          </person-group>
          <year>2013</year>
          <chapter-title>Integrating Heterogeneous and Distributed Information about Marine Species through a Top Level Ontology</chapter-title>
          <source>Communications in Computer and Information Science</source>
          <uri>https://doi.org/10.1007/978-3-319-03437-9_29</uri>
          <pub-id pub-id-type="doi">10.1007/978-3-319-03437-9_29</pub-id>
        </element-citation>
      </ref>
    </ref-list>
  </back>
  <floats-group>
    <fig id="F1433266" position="float" orientation="portrait">
      <label>Figure 1.</label>
      <caption>
        <p>An example of CSV data source exposed as an RDF dataset using a set of RML rules.</p>
      </caption>
      <graphic xlink:href="biodiversity_data_journal-3-e5464-g001.jpg" position="float" id="oo_41999.jpg" orientation="portrait" xlink:type="simple"/>
    </fig>
    <fig id="F1433270" position="float" orientation="portrait">
      <label>Figure 2.</label>
      <caption>
        <p>An example of output when reversing independent mappings.</p>
      </caption>
      <graphic xlink:href="biodiversity_data_journal-3-e5464-g002.jpg" position="float" id="oo_40763.jpg" orientation="portrait" xlink:type="simple"/>
    </fig>
    <fig id="F1540370" position="float" orientation="portrait">
      <label>Figure 3.</label>
      <caption>
        <p>Making explicit potential associations (guided by the target schema MarineTLO (<xref ref-type="bibr" rid="B1433042">Tzitzikas et al. 2013</xref>)) between the columns of the CSV data source.</p>
      </caption>
      <graphic xlink:href="biodiversity_data_journal-3-e5464-g003.jpg" position="float" id="oo_42005.jpg" orientation="portrait" xlink:type="simple"/>
    </fig>
    <fig id="F1540538" position="float" orientation="portrait">
      <label>Figure 4.</label>
      <caption>
        <p>The graph structures underlying the RML rules of Figs <xref ref-type="fig" rid="F1433266">1</xref>, <xref ref-type="fig" rid="F1540370">3</xref>.</p>
      </caption>
      <graphic xlink:href="biodiversity_data_journal-3-e5464-g004.jpg" position="float" id="oo_42034.jpg" orientation="portrait" xlink:type="simple"/>
    </fig>
    <fig id="F1540662" position="float" orientation="portrait">
      <label>Figure 5.</label>
      <caption>
        <p>Extention of the example of Fig. <xref ref-type="fig" rid="F1540370">3</xref> with 1:n association cardinality.</p>
      </caption>
      <graphic xlink:href="biodiversity_data_journal-3-e5464-g005.png" position="float" id="oo_42072.png" orientation="portrait" xlink:type="simple"/>
    </fig>
    <fig id="F1600992" position="float" orientation="portrait">
      <label>Figure 6.</label>
      <caption>
        <p>The results of comparing csv          <sup>o</sup> with csv   <sup>r </sup> (Suppl. material <xref ref-type="supplementary-material" rid="S1632696">1</xref>).</p>
      </caption>
      <graphic xlink:href="biodiversity_data_journal-3-e5464-g006.jpg" position="float" id="oo_43765.jpg" orientation="portrait" xlink:type="simple"/>
    </fig>
    <fig id="F1433327" position="float" orientation="portrait">
      <label>Figure 7.</label>
      <caption>
        <p>Exposing a CSV data source with 1:n implicit constraints using RML rules Fig. <xref ref-type="fig" rid="F1540370">3</xref>.</p>
      </caption>
      <graphic xlink:href="biodiversity_data_journal-3-e5464-g007.jpg" position="float" id="oo_43767.jpg" orientation="portrait" xlink:type="simple"/>
    </fig>
    <fig id="F1433329" position="float" orientation="portrait">
      <label>Figure 8.</label>
      <caption>
        <p>An example of a very “low” quality mappings.</p>
      </caption>
      <graphic xlink:href="biodiversity_data_journal-3-e5464-g008.jpg" position="float" id="oo_40770.jpg" orientation="portrait" xlink:type="simple"/>
    </fig>
    <fig id="F1600994" position="float" orientation="portrait">
      <label>Figure 9.</label>
      <caption>
        <p>An example of a key value column.</p>
      </caption>
      <graphic xlink:href="biodiversity_data_journal-3-e5464-g009.jpg" position="float" id="oo_43766.jpg" orientation="portrait" xlink:type="simple"/>
    </fig>
    <supplementary-material id="S1632696" orientation="portrait" position="float" xlink:type="simple">
      <label>Supplementary material 1</label>
      <caption>
        <p>RML2CSV evaluationn</p>
      </caption>
      <p>Data type: RML2CSV evaluation data</p>
      <p>File: oo_45207.xlsx</p>
      <media xlink:href="biodiversity_data_journal-3-e5464-s001.xlsx" mimetype="Microsoft Excel Document" mime-subtype="xlsx" position="float" orientation="portrait" xlink:type="simple"/>
      <attrib specific-use="authors">Carlo Allocca</attrib>
    </supplementary-material>
  </floats-group>
</article>